{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ephemeral PR environment using vCluster","text":"<p>In a fast-paced development environment, having an isolated and ephemeral environment to test changes for every pull request (PR) is a game-changer. In this blog, I\u2019ll walk you through setting up ephemeral PR environments using vCluster, enabling seamless testing of your application in a Kubernetes environment. We'll also leverage GitHub Actions for automation, ensuring every labeled PR dynamically creates a vCluster, deploys the application, and cleans up upon merging or label removal.</p> <p>Let\u2019s dive into the step-by-step guide.</p>"},{"location":"#what-is-vcluster","title":"What is vCluster?","text":"<p>vCluster is a technology that allows you to create lightweight, isolated Kubernetes clusters within a host cluster. These virtual clusters offer full Kubernetes functionality while being resource-efficient, making them ideal for scenarios like PR testing environments.</p>"},{"location":"#why-ephemeral-pr-environments","title":"Why Ephemeral PR Environments?","text":"<p>Ephemeral environments allow:</p> <ul> <li>Testing pull request changes in an isolated environment</li> <li>Quick validation without interfering with the main cluster</li> <li>Automatic cleanup post-testing By leveraging vCluster and GitHub Actions, you can automate this workflow and ensure every PR gets its own dedicated environment.</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites:","text":""},{"location":"#kubernetes-cluster","title":"Kubernetes cluster","text":"<p>You need to have a Kubernetes cluster, in this case I am using a DigitalOcean Kubernetes cluster but any should work. I am creating a realistic production scenario so for that I used a cluster that can create service type: LoadBalancer. </p> <p>Command: <code>kubectl get nodes</code></p> <pre><code>kubectl get nodes\nNAME              STATUS   ROLES    AGE   VERSION\nlive-demo-e0is0   Ready    &lt;none&gt;   19d   v1.31.1\nlive-demo-e0is1   Ready    &lt;none&gt;   19d   v1.31.1\nlive-demo-e0isz   Ready    &lt;none&gt;   19d   v1.31.1\n</code></pre>"},{"location":"#deploying-ingress-controller","title":"Deploying Ingress controller","text":"<p>Command</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml\n\n</code></pre> <p>Output</p> <pre><code>kubectl get po,svc -n ingress-nginx\nNAME                                           READY   STATUS      RESTARTS   AGE\npod/ingress-nginx-admission-create-lcb85       0/1     Completed   0          19d\npod/ingress-nginx-admission-patch-xl2fk        0/1     Completed   0          19d\npod/ingress-nginx-controller-79fcc99b4-7f7ls   1/1     Running     0          19d\n</code></pre> <p>Getting the LoadBalancer IP for the ingress controller:</p> <p>Command: <code>kubectl get svc -n ingress-nginx</code> Output:</p> <pre><code>NAME                                         TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)                      AGE\nservice/ingress-nginx-controller             LoadBalancer   10.109.28.126   209.38.160.229   80:31228/TCP,443:30435/TCP   19d\nservice/ingress-nginx-controller-admission   ClusterIP      10.109.15.162   &lt;none&gt;           443/TCP                      19d\n\n</code></pre> <p>Domain mapping:</p> <p>For our application we need dynamic ingress for testing so what we have done here is added the loadbalancer IP of the ingress controller as the A record to the Domain. </p> <p></p>"},{"location":"#connect-the-kubernetes-cluster-to-the-platform","title":"Connect the Kubernetes cluster to the platform","text":"<p>We will enable vCluster Pro in order to use templates and create the clusters.  For simplicity, I am using my vcluster.cloud account and then creating the access key to login. In this way I don\u2019t have to run any agent on the current cluster. You can either run vcluster platform start or sign up on vCluster cloud  and once you login, you should be able to go to access keys and create a short lived access key for the demo (remember to delete the key post demo for security reasons). </p> <p>Command:</p> <pre><code>vcluster platform login https://saiyam.vcluster.cloud --access-key &lt;your-access-key&gt;\n</code></pre> <p>Output:</p> <p>  Create a template under vCluster templates in the vCluster cloud platform instance.</p> <pre><code>sync:\n  fromHost:\n    ingressClasses:\n      enabled: true\n  toHost:\n    ingresses:\n      enabled: true\nexternal:\n  platform:\n    autoSleep:\n      afterInactivity: 3600  # Automatically sleep after 1 hour of inactivity\n</code></pre> <p>Until now we have a Kubernetes cluster with ingress controller installed and the Public IP of the nginx controller pointed to our domain. </p> <p>We also have logged into the platform using the access keys created using vcluster.cloud. Now let\u2019s see the demo application that we have. </p>"},{"location":"#demo-application","title":"Demo Application","text":"<p>  The scenario we are trying to achieve here involves a sample application deployed onto a Kubernetes cluster. Often, in organizations, new features or bug fixes need to be deployed and tested before being merged into the main branch. In this case, a developer raises a pull request and adds a label to test it. Based on GitHub Actions, the application is built, and then a deployment, service, and ingress Kubernetes object file are generated and pushed to a new branch. A virtual cluster is created, and the new deployment file is applied, allowing the developer to test and verify the new application deployment. </p> <p>Let\u2019s see how this looks in practice.  GitHub repo The application for this demo is a simple Go-based HTTP server:</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    \"html/template\"\n    \"net/http\"\n)\n\n//go:embed templates/*\nvar templatesFS embed.FS\n\n//go:embed static/*\nvar staticFS embed.FS\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    tmpl := template.Must(template.ParseFS(templatesFS, \"templates/index.html\"))\n    data := struct{ Title string }{Title: \"Welcome to the Multi-Tenancy March Series Powered by Loft Labs\"}\n    tmpl.Execute(w, data)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    http.Handle(\"/static/\", http.FileServer(http.FS(staticFS)))\n    http.ListenAndServe(\":8080\", nil)\n}\n\n</code></pre>"},{"location":"#step-1-setting-up-the-deployment-template","title":"Step 1: Setting Up the Deployment Template","text":"<p>The application is packaged as a Kubernetes deployment and exposed via a service and ingress. The deployment uses Jinja2 templating to inject dynamic values like the image tag and ingress host.</p> <p>tmpl/deploy.j2:</p> <pre><code>kind: Deployment\nmetadata:\n  name: workshop-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: workshop-app\n  template:\n    metadata:\n      labels:\n        app: workshop-app\n    spec:\n      containers:\n      - name: workshop-app\n        image: {{ image_deploy_tag }}\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: workshop-service\nspec:\n  selector:\n    app: workshop-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\n  namespace: default\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  ingressClassName: nginx\n  rules:\n  - host: {{ ingress_tag }}\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: workshop-service\n            port:\n              number: 80\n</code></pre>"},{"location":"#step-2-automating-with-github-actions","title":"Step 2: Automating with GitHub Actions","text":"<p>GitHub Actions handles the workflow from building the application to deploying it on a vCluster.</p> <p>PR Workflow File: .github/workflows/build-and-deploy.yml This workflow:</p> <ul> <li>Builds the application with the latest changes made by the developer using ko</li> <li>Pushes the container image to docker hub account(credentials for which should be set in the Actions secret as described previously)</li> <li>Creates a deployment manifest using Jinja2 - The action will replace the ingress host and the deployment image variables mentioned in the jinja template and then push to a new feature branch.</li> <li>Creates a vCluster.</li> <li>Deploys the application to the vCluster.</li> <li>Exposes it via ingress for testing.</li> </ul> <pre><code>name: Build and Deploy with vCluster\n\non:\n  pull_request:\n    types: [labeled]\n\njobs:\n  build-and-deploy:\n    if: ${{ github.event.label.name == 'test' }}\n    runs-on: ubuntu-latest\n\n    steps:\n      # Step 1: Checkout the PR Code\n      - name: Checkout PR Code\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.sha }}\n\n      # Step 2: Set up Go\n      - name: Set up Go\n        uses: actions/setup-go@v4\n        with:\n          go-version: '1.21'  # Matches your Dockerfile's golang:1.21-alpine\n\n      # Step 3: Initialize Go Module\n      - name: Initialize Go Module\n        working-directory: app\n        run: |\n          go mod init github.com/loftlabs-experiments/workshop-ephemeral-pr || echo \"Module already initialized\"\n          go mod tidy\n\n      # Step 4: Set up ko\n      - name: Set up ko\n        uses: ko-build/setup-ko@v0.6\n        with:\n          version: v0.14.1\n\n      # Step 5: Log into GHCR\n      - name: Log into GHCR\n        run: |\n          echo \"${{ secrets.GITHUB_TOKEN }}\" | ko login ghcr.io --username ${{ github.actor }} --password-stdin\n\n      # Step 6: Build and Push Image with ko\n      - name: Build and Push Image\n        working-directory: app\n        env:\n          KO_DOCKER_REPO: ghcr.io/loftlabs-experiments/workshop-ephemeral-pr\n          KO_DEFAULT_PLATFORM: linux/amd64\n        run: |\n          export IMAGE_TAG=sha-$(git rev-parse --short HEAD)\n          ko build . -t $IMAGE_TAG -t latest\n          echo \"image_deploy_tag=ghcr.io/loftlabs-experiments/workshop-ephemeral-pr:$IMAGE_TAG\" &gt;&gt; $GITHUB_ENV\n\n      # Step 7: Generate Deployment Manifest\n      - name: Generate Deployment Manifest\n        uses: cuchi/jinja2-action@v1.1.0\n        with:\n          template: tmpl/deploy.j2\n          output_file: deploy/deployment.yaml\n          strict: true\n          variables: |\n            image_deploy_tag=${{ env.image_deploy_tag }}\n            ingress_tag=pr${{ github.event.pull_request.number }}.vcluster.tech\n\n      # Step 8: Push to a Feature Branch\n      - name: Push Deployment Manifest\n        run: |\n          git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n          git config --global user.name \"github-actions[bot]\"\n          git checkout -b feature-test-${{ github.event.pull_request.head.sha }}\n          git add deploy/deployment.yaml\n          git commit -m \"Adding deployment.yaml for PR-${{ github.event.pull_request.number }}\" || echo \"No changes to commit\"\n          git push origin feature-test-${{ github.event.pull_request.head.sha }} --force\n\n      # Step 9: Install vCluster CLI\n      - name: Install vCluster CLI\n        uses: loft-sh/setup-vcluster@main\n        with:\n          url: ${{ secrets.VCLUSTER_PLATFORM_URL }}\n          access-key: ${{ secrets.VCLUSTER_ACCESS_KEY }}\n\n      # Step 10: Create vCluster\n      - name: Create A vCluster\n        uses: loft-sh/create-vcluster@main\n        with:\n          name: pr-${{ github.event.pull_request.number }}\n          project: default\n          template: my-template\n          parameters: |\n            - name: ingress_link\n              value: \"http://pr${{ github.event.pull_request.number }}.vcluster.tech\"\n\n      # Step 11: Deploy to vCluster\n      - name: Deploy Application to vCluster\n        run: |\n          kubectl apply -Rf deploy/\n\n      # Step 12: Test Application with curl\n      - name: Test Application\n        run: |\n          sleep 10  # Wait for the application to be ready\n          curl --retry 5 --retry-delay 10 http://pr${{ github.event.pull_request.number }}.vcluster.tech\n</code></pre>"},{"location":"#step-3-cleanup-workflow","title":"Step 3: Cleanup Workflow","text":"<p>Once the PR is merged or the label is removed, the ephemeral vCluster is deleted.</p> <p>File: .github/workflows/cleanup.yml</p> <pre><code>name: Clean Up vCluster\n\non:\n  pull_request:\n    types: [closed, unlabeled]\n\njobs:\n  cleanup:\n    if: (github.event.action == 'closed' &amp;&amp; github.event.pull_request.merged == true) || (github.event.action == 'unlabeled' &amp;&amp; github.event.label.name == 'test')\n    runs-on: ubuntu-latest\n\n    steps:\n      # Step 1: Install vCluster CLI\n      - name: Install vCluster CLI\n        uses: loft-sh/setup-vcluster@main\n        with:\n          url: ${{ secrets.VCLUSTER_PLATFORM_URL }}\n          access-key: ${{ secrets.VCLUSTER_ACCESS_KEY }}\n\n      # Step 2: Delete vCluster\n      - name: Delete vCluster\n        env:\n          NAME: pr-${{ github.event.pull_request.number }}\n        run: |\n          vcluster platform delete vcluster $NAME --project default --force || echo \"vCluster $NAME not found or already deleted\"\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<p>A developer creates a PR to do the feature changes.  With a small change the developer has raised a PR and now needs to add a test  label.</p> <p> As soon as the label is added the GitHub actions kicks off </p> <p>In the vCluster platform cloud instance you will be able to see the cluster getting created and the application will be deployed.    The Action is completed and pr14.vcluster.tech is created as part of ingress.</p> <p>The application is accessible at <code>http://pr&lt;PR_NUMBER&gt;.vcluster.tech</code>.</p> <p>As you can see  the latest changes made by the developer are deployed. </p> <p></p>"},{"location":"#cleanup","title":"Cleanup:","text":"<p>Upon PR merge or label removal, the ephemeral vCluster is automatically deleted. </p> <p>After merging, the cleanup action is triggered, which will clear the virtual cluster.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>Ephemeral PR environments using vCluster simplify testing, reduce resource usage, and provide a seamless developer experience. By combining vCluster with GitHub Actions, you can achieve an automated and efficient workflow for testing PRs.</p>"}]}